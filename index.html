<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="keywords" content="TypeScript">
    <meta name="author" content="Michal Dorner">

    <title>TypeScript - JavaScript that scales</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/dorny.css" id="theme">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
</head>

<body>
    <div class="reveal">
        <div class="slides">

            <section data-markdown>
                <script type="text/template">
                    ## Modern Web Development with
                    # [TypeScript](https://www.typescriptlang.org/)

                    Slides: [https://dorny.github.io/typescript-intro](https://dorny.github.io/typescript-intro/)
                </script>
            </section>

            <section>
                <h2>Why is plain JavaScript not sufficient itself?</h2>

                <div class="fragment" data-markdown>
                    <script type="text/template">
                        - **Before**:
                            - Web pages

                        - **Now**:
                            - Web applications (SPA)
                            - Server (Node.js)
                            - Mobile (Cordova)
                            - Desktop (Electron,UWP)
                    </script>
                </div>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Why is plain JavaScript not sufficient itself?

                    - Dynamically typed:
                        - Poor autocomplete (IntelliSense) and navigation
                        - Errors discovered at runtime
                        - Refactoring is error prone
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Why is JavaScript not sufficient itself?

                    ```js
                    function DoSomethingImportant(book) {
                        // What is the type of "book" ?
                        // No autocomplete for you...
                    }

                    // ....

                    var book = {
                        author: 'John Doe'
                        title: 'JavaScript daily WTF'
                    };

                    DoSomethingImporatnt(book);
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Why is JavaScript not sufficient itself?

                    - Weird syntax/behavior (**fixed in es6**):
                        - Classes
                        - Lambdas
                        - Scope of `var` variables
                        - Rest Parameters
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Why using type annotations?

                    * Can make code more readable
                    * Can make code easier to analyse
                    * Can allow for reliable refactoring
                    * Can allow for generally better IDE support
                    * Can catch some (type related) errors early
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## There are more than [250 "languages"](https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS) that compile to JS
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Google Closure Tools

                    * Used in: _Gmail_, _Google Docs_, _Google Maps_...
                    * Optional type anotations in _JSDoc_ comments

                    ```js
                    /**
                    * @param {string} bar
                    * @return {boolean}
                    */
                    function foo(bar) { return true; }
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## CoffeeScript

                    ```coffeescript
                    # Conditions:
                    number = -42 if opposite

                    # Functions:
                    square = (x) -> x * x

                    # Objects:
                    math =
                    root:   Math.sqrt
                    square: square
                    cube:   (x) -> x * square x
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Flow

                    ### Static type checker for JavaScript

                    * Developed and maintained by Facebook
                    * Optional type annotations
                    * _Babel_ is used to transpile code to plain JavaScript
                    * Easy to use on existing JavaScript project
                    * IDE support & tools not as mature as for TypeScript
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## TypeScript

                    * Superset of JavaScript designed for large scale application development
                    * Developed and maintained by Microsoft
                    * Free, open source and fully production ready
                    * Public since October 2012 (at version 0.8), after two years of internal development at Microsoft
                    * Work by _Anders Hejlsberg_, lead architect of C# and creator of Delphi and Turbo Pascal
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## TypeScript Basics
                    * How to declare a variable
                    * Basic types
                    * How to write a function
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Variable Declarations
                    * `var` - function scope
                    * `let` - block scope
                    * `const` - block scope + value cannot be changed
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Variable Declarations

                    ``` typescript
                    "use strict";

                    (function() {
                        // `var` variables are valid in whole function scope.
                        // Doesn't matter where they are declared.
                        foo = true;
                        var foo;

                        if (foo) {
                            let bar = true;

                            const foobar = 3;

                            // Error: Left-hand side of assignment cannot be a constant
                            /* foobar = 4; */
                        }

                        // Error: Cannot find name 'bar'
                        /* console.log(bar); */
                    }());
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Variable Declarations

                    What do you think will be written to the console?

                    ``` typescript
                    for (var i = 0; i<3; i++) {
                        for (var i = 0; i<3; i++) {
                            console.log(i);
                        }
                    }
                    ```

                    Output: <!-- .element: class="fragment" data-fragment-index="1" -->
                    ``` typescript
                    0
                    1
                    2
                    ```
                    <!-- .element: class="fragment" data-fragment-index="1" -->
                    </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Variable Declarations

                    Using `let` fixes the issue.
                    ``` typescript
                    for (let i = 0; i<3; i++) {
                        for (let i = 0; i<3; i++) {
                            console.log(i);
                        }
                    }
                    ```

                    Output:
                    ``` typescript
                    0
                    1
                    2
                    0
                    1
                    2
                    0
                    1
                    2
                    ```
                    </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Variable capturing quirks

                    What do you think will be written to the console?
                    ``` typescript
                    for (var i = 0; i < 5; i++) {
                        setTimeout(function() {console.log(i); }, 100 * i);
                    }
                    ```

                    Output: <!-- .element: class="fragment" data-fragment-index="1" -->
                    ``` typescript
                    5
                    5
                    5
                    5
                    5
                    ```
                    <!-- .element: class="fragment" data-fragment-index="1" -->
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Variable capturing quirks

                    Using `let` fixes the issue.
                    ``` typescript
                    for (let i = 0; i < 5; i++) {
                        setTimeout(function() {console.log(i); }, 100 * i);
                    }
                    ```

                    Output:
                    ``` typescript
                    0
                    1
                    2
                    3
                    4
                    ```
                </script>
            </section>

            <section>
                <h2>Basic Types</h2>
                <div class="left" style="float:left;width:48%">
                    <ul>
                        <li>Boolean</li>
                        <li>Number</li>
                        <li>String</li>
                        <li>Array</li>
                        <li>Object</li>
                        <li>Undefined</li>
                    </ul>
                </div>
                <div class="right" style="float:right;width:48%">
                    <ul>
                        <li>Enum</li>
                        <li>Tuple</li>
                        <li>Any</li>
                        <li>Void</li>
                        <li>Never</li>
                    </ul>
                </div>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Boolean

                    ``` typescript
                    // Type is optionally specified after variable name
                    let isDone: boolean = false;

                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Number
                    As in JavaScript, all numbers in TypeScript are floating point values.

                    ``` typescript
                    let decimal: number = 6;

                    let hex: number = 0xf00d;

                    let binary: number = 0b1010;

                    let octal: number = 0o744;
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## String
                    * both single `'` and double `"` quotes can be used.

                    ``` typescript
                    let color: string = "blue";
                    color = 'red';
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Template Strings
                    * can span multiple lines
                    * can have embedded expressions

                    ```typescript
                    let fullName: string = `Bob Bobbington`;
                    let sentence: string = `Hello, my name is ${ fullName }.

                    let age: number = 37;
                    I'll be ${ age + 1 } years old next month.`
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Array

                    ``` typescript
                    let list: number[] = [1, 2, 3];

                    let list: Array<number> = [1, 2, 3];

                    let first: number = list[0]
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Array destructuring

                    ``` typescript
                    let input = [1, 2, 3, 4];
                    let [first, second, ...rest] = input;

                    console.log(first);  // outputs 1
                    console.log(second); // outputs 2
                    console.log(rest);   // outputs [ 3, 4 ]
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Object

                    ``` typescript
                    let book = {
                        title: "TypeScript for dummies",
                        author: "John Doe",
                        year: 2016
                    };

                    console.log(book.author); // "John Doe"
                    console.log(book.title);  // "TypeScript for dummies"

                    let bookObject : Object = book;

                    // Error: Property 'author' does not exist on type 'Object'.
                    console.log(bookObject.author);
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Object destructuring

                    ``` typescript
                    let book = {
                        title: "TypeScript for dummies",
                        author: "John Doe",
                        year: 2016
                    };

                    let {author, title: bookTitle} = book;
                    console.log(author);    // "John Doe"
                    console.log(bookTitle); // "TypeScript for dummies"
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Enum

                    ``` typescript
                    // By default, enums begin numbering their members starting at 0
                    enum Color {Red, Green, Blue = 4};

                    // Store enum variant in a variable
                    let c: Color = Color.Green;

                    // It's possible to get string name of an enum variant
                    let colorName: string = Color[Color.Green]; // "Green"
                    let colorName: string = Color[0];           // "Red"
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Enum

                    ``` typescript
                    enum FileAccess {
                        // constant members
                        None,
                        Read    = 1 << 1,
                        Write   = 1 << 2,
                        ReadWrite  = Read | Write,

                        // computed member
                        G = "123".length
                    }
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Tuple

                    ``` typescript
                    // Declare a tuple type
                    let x: [string, number];

                    // Initialize it
                    x = ["hello", 10]; // OK

                    // Initialize it incorrectly
                    x = [10, "hello"]; // Error

                    ```
                </script>
            </section>

            <section data-markdown data-separator-notes="^Note:">
                <script type="text/template">
                    ## Any

                    Using default compiler settings, all variables without type anotations are treated as `any`.

                    ``` typescript
                    let notSure: any = false;
                    notSure = "maybe a string instead";
                    notSure = 4;

                    notSure.toFixed(); // okay, toFixed exists
                                       // (but the compiler doesn't check)

                    notSure.ifItExists(); // Runtime error
                    ```

                    Note:
                    Object only allow you to assign any value to them – you can’t call arbitrary methods on them, even ones that actually exist.
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Void

                    void is a little like the opposite of any: the absence of having any type at all.
                    You may commonly see this as the return type of functions that do not return a value.

                    ``` typescript
                    function warnUser(): void {
                        alert("This is my warning message");
                    }
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Never

                    Represents the type of values that never occur.

                    ``` typescript
                    // Function returning never must have unreachable end point
                    function error(message: string): never {
                        throw new Error(message);
                    }

                    // Inferred return type is never
                    function fail() {
                        return error("Something failed");
                    }

                    // Function returning never must have unreachable end point
                    function infiniteLoop(): never {
                        while (true) { }
                    }
                    ```
                </script>
            </section>


            <section data-markdown>
                <script type="text/template">
                    ## Functions

                    ``` typescript
                    function buildName(name: string, name?: string): string {
                        // ...
                    }

                    function buildName(name: string, name = "Smith"): string {
                        // ...
                    }

                    function buildName(name: string, ...rest: string[]): string {
                        // ...
                    }

                    // Lamda syntax
                    let buildName: (stirng, string) => string;
                    buildName = (first, last) => `${first} + ${last}`;
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## TypeScript in Depth
                    * Interfaces
                    * Generics
                    * Union & Intersection types
                    * Classes
                    * Modules
                </script>
            </section>


            <section data-markdown>
                <script type="text/template">
                    ## Interfaces

                    One of TypeScript’s core principles is that type-checking focuses on the shape that values have.

                    ```
                    interface LabelledValue {
                        label: string;
                    }

                    function printLabel(labelledObj: LabelledValue) {
                        console.log(labelledObj.label);
                    }

                    let myObj = {size: 10, label: "Size 10 Object"};
                    printLabel(myObj);
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Interfaces - Optional Properties

                    ``` typescript
                    interface SquareConfig {
                        color?: string;
                        width?: number;
                    }

                    function createSquare(config: SquareConfig) {
                        let newSquare = {color: "white", area: 100};
                        if (config.color) {
                            newSquare.color = config.color;
                        }
                        if (config.width) {
                            newSquare.area = config.width * config.width;
                        }
                        return newSquare;
                    }

                    let mySquare = createSquare({color: "black"});
                    ```
                </script>
            </section>

            <section>
                <h2>Interfaces - Optional Properties</h2>

                <pre><code data-trim data-noescape class="typescript">
interface SquareConfig {
    color?: string;
    width?: number;
}

function createSquare(config: SquareConfig) {
    // ...
}

let mySquare = createSquare({color: "black", <mark>widht</mark>: 50});
                </code></pre>

                Compile time error:

                <pre><code data-trim data-noescape class="text">
<mark>test.ts(17,47): error TS2345: Argument of type
'{ color: string; widht: number; }'
is not assignable to parameter of type 'SquareConfig'.
Object literal may only specify known properties,
and 'widht' does not exist in type 'SquareConfig'.</mark>
                </code></pre>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Interfaces - Function Types

                    ``` typescript
                    interface SearchFunc {
                        (source: string, subString: string): boolean;
                    }

                    let mySearch : SearchFunc;
                    mySearch = (source: string, subString: string) => {
                        // ...
                        return true;
                    };
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Interfaces - Indexable Types

                    ``` typescript
                    interface StringArray {
                        [index: number]: string;
                    }

                    interface StringDictionary {
                        [index: string]: string;
                    }

                    let stringArray: StringArray;
                    stringArray = ["Bob", "Fred"];

                    let stringDictionary : StringDictionary;
                    stringDictionary = { "key": "value" };
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Interfaces - Class Constructors

                    ``` typescript
                    interface ClockConstructor {
                        new (hour: number, minute: number): ClockInterface;
                    }
                    interface ClockInterface { }

                    function createClock(
                        ctor: ClockConstructor, hour: number, minute: number
                    ): ClockInterface {
                        return new ctor(hour, minute);
                    }

                    class DigitalClock implements ClockInterface {
                        constructor(h: number, m: number) { }
                    }
                    class AnalogClock implements ClockInterface {
                        constructor(h: number, m: number) { }
                    }

                    let digital = createClock(DigitalClock, 12, 17);
                    let analog = createClock(AnalogClock, 7, 32);
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Extending Interfaces

                    ``` typescript
                    interface Shape {
                        color: string;
                    }

                    interface Square extends Shape {
                        sideLength: number;
                    }

                    function printSquare(square: Square) {
                        console.log(`color: ${square.color}, length:${square.sideLength}`);
                    }
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Generics

                    // TODO
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Union Types

                    A union type describes a value that can be one of several types.

                    ``` typescript
                    function padLeft(value: string, padding: string | number) {
                        if (typeof padding === "number") {
                            return Array(padding + 1).join(" ") + value;
                        }
                        if (typeof padding === "string") {
                            return padding + value;
                        }
                        throw new Error(`Expected string or number, got '${padding}'.`);
                    }
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Intersection Types

                    An intersection type have all members of all specified types.

                    ``` typescript

                    interface Entity {
                        id: number;
                    }

                    interface Serializable {
                        serialize(): string;
                    }

                    function store(entity: Entity & Serializable) {
                        let storage = window.localStorage;
                        let key = entity.id.toString();
                        storage.setItem(key, entity.serialize());
                    }
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## String Literal Types

                    String literal types allow you to specify the exact value a string must have.

                    ``` typescript
                    type Easing = "ease-in" | "ease-out" | "ease-in-out";

                    class UIElement {
                        animate(dx: number, dy: number, easing: Easing) {
                            // ...
                        }
                    }

                    let button = new UIElement();
                    button.animate(0, 0, "ease-in");
                    button.animate(0, 0, "uneasy"); // error: "uneasy" is not allowed here
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Discriminated Unions

                    * Common string literal property is used as discriminant

                    ``` typescript
                    interface Square {
                        kind: "square";
                        size: number;
                    }
                    interface Circle {
                        kind: "circle";
                        radius: number;
                    }

                    type Shape = Square | Circle;

                    function area(s: Shape) {
                        switch (s.kind) {
                            case "square": return s.size * s.size;
                            case "circle": return Math.PI * s.radius ** 2;
                        }
                    }
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Type assertions

                    Sometimes you’ll end up in a situation where you’ll know more about a value than TypeScript does.

                    ``` typescript
                    let someValue: any = "this is a string";

                    let strLength: number = (someValue as string).length;
                    let worksToo: number = (<string>someValue).length;
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Type Guards

                    ``` typescript
                    function isNumber(x: any): x is number {
                        return typeof x === "number";
                    }

                    function isString(x: any): x is string {
                        return typeof x === "string";
                    }

                    function padLeft(value: string, padding: string | number) {
                        if (isNumber(padding)) {
                            return Array(padding + 1).join(" ") + value;
                        }
                        if (isString(padding)) {
                            return padding + value;
                        }
                        throw new Error(`Expected string or number, got '${padding}'.`);
                    }
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Class declarations

                    * Brings OOP to today's JavaScript
                    * `abstract`
                    * `extends` / `implements`
                    * Access modifiers:
                         - `public` (default)
                         - `protected`
                         - `private`
                    * instance / static properties and methods
                    * `readonly` properties
                </script>
            </section>


            <section data-markdown>
                <script type="text/template">
                    ## Class declarations

                    ``` typescript
                    class Greeter {
                        private greeting: string;

                        constructor(message: string) {
                            this.greeting = message;
                        }

                        greet() {
                            return "Hello, " + this.greeting;
                        }
                    }

                    let greeter = new Greeter("world");
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Class declarations

                    ``` js
                    var Greeter = (function () {

                        function Greeter(message) {
                            this.greeting = message;
                        }

                        Greeter.prototype.greet = function () {
                            return "Hello, " + this.greeting;
                        };

                        return Greeter;
                    }());

                    var greeter = new Greeter("world");
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Class declarations

                    ```
                    class Animal {
                        protected name: string;

                        constructor(theName: string) {
                            this.name = theName;
                        }

                        move(distanceInMeters: number = 0) {
                            console.log(`${this.name} moved ${distanceInMeters}m.`);
                        }
                    }

                    class Snake extends Animal {
                        constructor(name: string) {
                            super(name);
                        }

                        move(distanceInMeters = 5) {
                            console.log("Slithering...");
                            super.move(distanceInMeters);
                        }
                    }
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Polymorphic this types

                    ``` typescript
                    class BasicCalculator {
                        protected value: number = 0;
                        public currentValue(): number {
                            return this.value;
                        }
                        public add(operand: number): this {
                            this.value += operand;
                            return this;
                        }
                    }

                    class ScientificCalculator extends BasicCalculator {
                        public sin() {
                            this.value = Math.sin(this.value);
                            return this;
                        }
                    }

                    let v = new ScientificCalculator().add(1).sin().currentValue();
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Modules

                    * Starting with ES6, JavaScript has a concept of modules, TypeScript shares this concept
                    * Modules are executed within their own scope
                    * Modules are declarative, the relationships are specified as imports and exports at the file level
                    * Modules import one another using a module loader
                    * Any file containing a top-level `import` or `export` is considered a module
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Modules - Export

                    Any declaration (variable, function, class, type alias, or interface) can be exported by `export` keyword.

                    ``` typescript
                    /* Validators.ts */

                    export interface StringValidator {
                        isAcceptable(s: string): boolean;
                    }

                    export default function Validate(
                            value: string, validator: StringValidator) : bool {
                        // ...
                    }
                    ```

                    ``` typescript
                    /* ZipCodeValidator.ts */

                    export const NumberRegexp = /^[0-9]+$/;
                    export default sclass ZipCodeValidator implements StringValidator {
                        isAcceptable(s: string) {
                            return s.length === 5 && NumberRegexp.test(s);
                        }
                    }
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Modules - Import

                    ``` typescript
                    // Import named exports
                    import { ZipCodeValidator, NumberRegexp } from "./ZipCodeValidator";

                    // Rename imported item
                    import { ZipCodeValidator as zcv } from "./ZipCodeValidator";

                    // Import the entire module into a single variable
                    import * as validator from "./ZipCodeValidator";
                    let myValidator = new validator.ZipCodeValidator();

                    // Import `export default` item
                    import validate from "./Validators";
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Modules - Code Generation

                    // TODO

                    ``` js

                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Namespaces

                    * Takes place of older concept of "Internal Modules"
                    * It's different concept of code organization than modules
                    * Exporting a namespace from your module is an example of adding too many layers of nesting
                    * Can be useful for ambient declarations of some external libraries
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## TypeScript Advanced Topics
                    * `async` / `await`
                    * Decorators
                    * JSX
                    * Mixins
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## `async` / `await`

                    ``` typescript
                    async function printDelayed(elements: string[]) {
                        for (const element of elements) {
                            await delay(200);
                            console.log(element);
                        }
                    }

                    async function delay(milliseconds: number) {
                        return new Promise<void>(resolve => {
                            setTimeout(() => resolve(), milliseconds);
                        });
                    }

                    printDelayed(["Hello", "asynchronous", "world!"])
                        .then(() => {
                            console.log("Printed every element!");
                        });
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Decorators

                    // TODO
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## JSX

                    // TODO
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## Mixins

                    ``` typescript
                    // Disposable Mixin
                    class Disposable {
                        isDisposed: boolean;
                        dispose() {
                            this.isDisposed = true;
                        }
                    }

                    class SmartObject implements Disposable {

                        // Disposable
                        isDisposed: boolean = false;
                        dispose: () => void;
                    }

                    // Custom function to copy methods from mixins to target class
                    applyMixins(SmartObject, [Disposable]);
                    ```
                </script>
            </section>

            <section>
                <h3>Thanks</h3>
                <!--<img class="logo" src="img/typescript-logo.svg" alt="TypeScript logo" width="50%" height="auto" />-->
                <h3><a href="https://www.typescriptlang.org/">www.typescriptlang.org</a></h3>
            </section>

            <section data-markdown>
                <script type="text/template">
                    ## FUN ;)

                    [WAT @garybernhardt](https://www.destroyallsoftware.com/talks/wat)
                </script>
            </section>

        </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
            // More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,
                transition: 'none',

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});

            var themes = [
                'beige',
                'black',
                'blood',
                'dorny',
                'league',
                'moon',
                'night',
                'serif',
                'simple',
                'sky',
                'solarized',
                'white'
            ];

            var themesPath = 'css/theme/';

            // Hack for live theme changing
            document.addEventListener("keypress", function(event){
                if (event.key != 't') return;

                // loop over themes
                themes.push(themes.shift());

                // set current theme
                document.getElementById('theme').setAttribute('href','css/theme/'+themes[0]+'.css')

                return false;
            });
    </script>
</body>

</html>